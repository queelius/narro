/**
 * Verify JS ISTFT matches Python/PyTorch output.
 * Run: node test_istft.mjs
 *
 * Requires: Python test data at /tmp/istft_test_data.json
 * Generate with: python3 -c "..." (see below)
 */
import { readFileSync } from 'fs';
import { irfft } from './fft.mjs';

// Constants (must match soprano-decoder.mjs)
const N_FFT = 2048;
const HOP_LENGTH = 512;
const N_FREQ = N_FFT / 2 + 1; // 1025

// ISTFT implementation (duplicated from soprano-decoder.mjs for standalone testing)
function hannWindow(length) {
  const w = new Float64Array(length);
  for (let i = 0; i < length; i++) {
    w[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / length));
  }
  return w;
}

function istft(magPhase, T) {
  const window = hannWindow(N_FFT);
  const windowSq = new Float64Array(N_FFT);
  for (let i = 0; i < N_FFT; i++) windowSq[i] = window[i] * window[i];

  const outputLen = N_FFT + HOP_LENGTH * (T - 1);
  const output = new Float64Array(outputLen);
  const windowEnvelope = new Float64Array(outputLen);

  const halfRe = new Float64Array(N_FREQ);
  const halfIm = new Float64Array(N_FREQ);

  for (let t = 0; t < T; t++) {
    for (let k = 0; k < N_FREQ; k++) {
      const rawMag = magPhase[k * T + t];
      const phase = magPhase[(N_FREQ + k) * T + t];
      const mag = Math.min(Math.exp(rawMag), 100);

      halfRe[k] = mag * Math.cos(phase);
      halfIm[k] = mag * Math.sin(phase);
    }

    halfRe[0] = 0; halfIm[0] = 0;
    halfRe[N_FREQ - 1] = 0; halfIm[N_FREQ - 1] = 0;

    const frame = irfft(halfRe, halfIm, N_FFT);

    const offset = t * HOP_LENGTH;
    for (let i = 0; i < N_FFT; i++) {
      output[offset + i] += frame[i] * window[i];
      windowEnvelope[offset + i] += windowSq[i];
    }
  }

  for (let i = 0; i < outputLen; i++) {
    if (windowEnvelope[i] > 1e-11) {
      output[i] /= windowEnvelope[i];
    }
  }

  const pad = N_FFT >> 1;
  const trimmedLen = outputLen - 2 * pad;
  const result = new Float32Array(trimmedLen);
  for (let i = 0; i < trimmedLen; i++) {
    result[i] = output[pad + i];
  }
  return result;
}

// Load test data generated by Python
const testDataPath = '/tmp/istft_test_data.json';

try {
  readFileSync(testDataPath);
} catch {
  console.error(`Test data not found at ${testDataPath}.`);
  console.error('Generate it with: python3 generate_test_data.py');
  process.exit(1);
}

const data = JSON.parse(readFileSync(testDataPath, 'utf-8'));
const magPhase = new Float32Array(data.mag_phase);
const expected = new Float64Array(data.expected);
const T = data.T;

console.log(`Test: ISTFT with T=${T} frames`);
console.log(`  Expected audio length: ${expected.length}`);

// Run JS ISTFT
const actual = istft(magPhase, T);
console.log(`  Actual audio length: ${actual.length}`);

if (actual.length !== expected.length) {
  console.error(`  FAIL: Length mismatch (expected ${expected.length}, got ${actual.length})`);
  process.exit(1);
}

// Compute errors
let maxErr = 0;
let sumSqErr = 0;
let sumSqRef = 0;
for (let i = 0; i < actual.length; i++) {
  const err = Math.abs(actual[i] - expected[i]);
  maxErr = Math.max(maxErr, err);
  sumSqErr += err * err;
  sumSqRef += expected[i] * expected[i];
}
const rmse = Math.sqrt(sumSqErr / actual.length);
const relErr = Math.sqrt(sumSqErr / (sumSqRef + 1e-10));

console.log(`  Max absolute error: ${maxErr.toExponential(4)}`);
console.log(`  RMSE: ${rmse.toExponential(4)}`);
console.log(`  Relative error: ${relErr.toExponential(4)}`);

console.log(`  First 10 expected: ${Array.from(expected.slice(0, 10)).map(v => v.toFixed(6)).join(', ')}`);
console.log(`  First 10 actual:   ${Array.from(actual.slice(0, 10)).map(v => v.toFixed(6)).join(', ')}`);

if (maxErr < 1e-3) {
  console.log('  PASS');
} else if (maxErr < 1e-2) {
  console.log('  PASS (marginal â€” float32 rounding)');
} else {
  console.error(`  FAIL: Max error ${maxErr} exceeds threshold`);
  process.exit(1);
}
